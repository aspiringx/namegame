generator client {
  provider        = "prisma-client-js"
  output          = "../src/generated/prisma"

}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model User {
  id               String      @id @default(cuid())
  username         String      @unique
  password         String
  firstName        String
  lastName         String?
  email            String?     @unique
  emailVerified    DateTime?
  phone            String?     @unique
  phoneVerified    DateTime?
  gender               Gender?
  birthDate          DateTime?
  birthPlace         String?
  birthDatePrecision DatePrecision?
  deathDate          DateTime?
  deathDatePrecision DatePrecision?
  deathPlace         String?
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt
  deletedAt        DateTime?
  createdById      String?
  updatedById      String?
  accounts         Account[]
  sessions         Session[]
  emailVerificationTokens EmailVerificationToken[]
  codes            Code[]
  greetingsSent    Greeting[]  @relation("GreetingUser1")
  greetingsRcvd    Greeting[]  @relation("GreetingUser2")
  groupMemberships GroupUser[]
  createdGroups    Group[]     @relation("GroupCreatedBy")
  updatedGroups    Group[]     @relation("GroupUpdatedBy")
  messages         Message[]
  photos           Photo[]
  userRelations1   UserUser[]  @relation("User1Relation")
  userRelations2   UserUser[]  @relation("User2Relation")
  createdBy        User?       @relation("UserCreatedBy", fields: [createdById], references: [id])
  createdUsers     User[]      @relation("UserCreatedBy")
  updatedBy        User?       @relation("UserUpdatedBy", fields: [updatedById], references: [id])
  updatedUsers     User[]      @relation("UserUpdatedBy")
  managed          ManagedStatus?
  managing         ManagedUser[] @relation("ManagingUsers")
  managedBy        ManagedUser[] @relation("ManagedUsers")
  pushSubscriptions PushSubscription[]
  chatParticipants ChatParticipant[]
  chatMessages     ChatMessage[]
  chatReactions    ChatMessageReaction[]
  hiddenMessages   ChatMessage[]       @relation("HiddenMessages")
  aiRequests       AIRequest[]

  @@map("users")
}

model UserUser {
  id             Int      @id @default(autoincrement())
  user1Id        String
  user2Id        String
  greetCount     Int                  @default(0)
  relationTypeId Int
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt
  deletedAt      DateTime?
  user1          User                 @relation("User1Relation", fields: [user1Id], references: [id])
  user2          User                 @relation("User2Relation", fields: [user2Id], references: [id])
  relationType   UserUserRelationType @relation(fields: [relationTypeId], references: [id])

  @@unique([user1Id, user2Id, relationTypeId])
  @@map("user_users")
}

model ManagedUser {
  managerId  String
  managedId  String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  manager    User     @relation("ManagingUsers", fields: [managerId], references: [id], onDelete: Cascade)
  managed    User     @relation("ManagedUsers", fields: [managedId], references: [id], onDelete: Cascade)

  @@id([managerId, managedId])
  @@map("managed_users")
}

model Group {
  id                     Int                      @id @default(autoincrement())
  idTree                 String                   @unique
  name                   String
  slug                   String                   @unique
  description            String?
  address                String?
  phone                  String?
  parentId               Int?
  createdById            String?
  updatedById            String?
  createdBy              User?                    @relation("GroupCreatedBy", fields: [createdById], references: [id])
  updatedBy              User?                    @relation("GroupUpdatedBy", fields: [updatedById], references: [id])
  createdAt              DateTime                 @default(now())
  updatedAt              DateTime                 @updatedAt
  deletedAt              DateTime?
  parent                 Group?                   @relation("GroupToGroup", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  children               Group[]                  @relation("GroupToGroup")
  members                GroupUser[]
  codes                  Code[]
  links                  Link[]
  iceBreakers            IceBreaker[]
  photos                 Photo[]
  groupTypeId            Int
  groupType              GroupType  @relation(fields: [groupTypeId], references: [id])
  chatConversations      ChatConversation[]

  @@map("groups")
}

model GroupUser {
  userId      String
  groupId     Int
  roleId      Int
  memberSince Int?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deletedAt   DateTime?
  group       Group    @relation(fields: [groupId], references: [id])
  user        User     @relation(fields: [userId], references: [id])
  role        GroupUserRole @relation(fields: [roleId], references: [id])

  @@id([userId, groupId])
  @@map("group_users")
}

model Code {
  id            Int      @id @default(autoincrement())
  userId        String
  parentGroupId Int?
  groupId       Int?
  code          String   @unique
  createdAt     DateTime @default(now())
  group         Group?   @relation(fields: [groupId], references: [id])
  user          User     @relation(fields: [userId], references: [id])

  @@index([userId, groupId])
  @@map("codes")
}

model Photo {
  id           Int        @id @default(autoincrement())
  userId       String?
  groupId      Int?
  entityTypeId Int
  entityId     String
  url          String
  url_thumb    String?
  url_small    String?
  url_medium   String?
  url_large    String?
  typeId       Int
  isBlocked    Boolean    @default(false)
  uploadedAt   DateTime   @default(now())
  createdAt    DateTime   @default(now())
  deletedAt    DateTime?
  group        Group?     @relation(fields: [groupId], references: [id])
  user         User?      @relation(fields: [userId], references: [id])
  entityType   EntityType @relation(fields: [entityTypeId], references: [id])
  type         PhotoType  @relation(fields: [typeId], references: [id])

  @@map("photos")
}

model Message {
  id            Int        @id @default(autoincrement())
  userId        String
  entityTypeId  Int
  entityId      Int
  message       String
  recipientType String
  recipientId   Int
  isBlocked     Boolean    @default(false)
  createdAt     DateTime   @default(now())
  deletedAt     DateTime?
  user          User       @relation(fields: [userId], references: [id])
  entityType    EntityType @relation(fields: [entityTypeId], references: [id])

  @@map("messages")
}

model Greeting {
  id        Int      @id @default(autoincrement())
  user1Id   String
  user2Id   String
  geo       String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user1     User     @relation("GreetingUser1", fields: [user1Id], references: [id])
  user2     User     @relation("GreetingUser2", fields: [user2Id], references: [id])

  @@map("greetings")
}

model IceBreaker {
  id        Int      @id @default(autoincrement())
  groupId   Int
  question  String
  createdAt DateTime @default(now())
  group     Group    @relation(fields: [groupId], references: [id])

  @@map("ice_breakers")
}

model Link {
  id          Int      @id @default(autoincrement())
  groupId     Int
  url         String
  title       String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  group       Group    @relation(fields: [groupId], references: [id])

  @@map("links")
}

enum UserUserRelationCategory {
  family
  other
}

enum Gender {
  male
  female
  non_binary
}

enum DatePrecision {
  YEAR
  MONTH
  DAY
  TIME
  TIMESTAMP
}

enum ManagedStatus {
  full
  partial
}

// Code Tables

model GroupType {
  id     Int     @id @default(autoincrement())
  code   String  @unique
  groups Group[]

  @@map("group_types")
}

model UserUserRelationType {
  id        Int        @id @default(autoincrement())
  code      String
  category  UserUserRelationCategory
  userUsers UserUser[]

  @@unique([code, category])
  @@map("user_user_relation_types")
}

model GroupUserRole {
  id      Int         @id @default(autoincrement())
  code    String      @unique
  members GroupUser[]

  @@map("group_user_roles")
}

model EntityType {
  id       Int       @id @default(autoincrement())
  code     String    @unique
  photos   Photo[]
  messages Message[]

  @@map("entity_types")
}

model PhotoType {
  id     Int     @id @default(autoincrement())
  code   String  @unique
  photos Photo[]

  @@map("photo_types")
}

model EmailVerificationToken {
  id        String   @id @default(cuid())
  token     String   @unique
  expires   DateTime
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@index([userId])
}

model PasswordResetToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

// Push notification subscription model.
model PushSubscription {
  id         String   @id @default(cuid())
  endpoint   String   @unique
  p256dh     String
  auth       String
  userId     String
  fcmToken   String? // FCM/Firebase token needed for Google Chrome/Android.
  browser    String? // Browser name (chrome, safari, firefox, edge, brave)
  os         String? // Operating system (ios, android, macos, windows, linux)
  deviceType String? // Device type (mobile, tablet, desktop)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@index([userId])
  @@index([userId, browser, os, deviceType])
}

// Chat system models
model ChatConversation {
  id            String              @id @default(cuid())
  type          String              // 'direct' for person-to-person, 'group' for group-wide
  groupId       Int?                // NULL for direct messages, set for group chats
  name          String?             // Optional name for group conversations
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  lastMessageAt DateTime?           // For sorting conversations by activity
  
  // Relations
  group         Group?              @relation(fields: [groupId], references: [id], onDelete: Cascade)
  participants  ChatParticipant[]
  messages      ChatMessage[]
  
  @@map("chat_conversations")
}

model ChatParticipant {
  id             String           @id @default(cuid())
  conversationId String
  userId         String
  joinedAt       DateTime         @default(now())
  lastReadAt     DateTime?        // For unread message tracking
  
  // Relations
  conversation   ChatConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([conversationId, userId])
  @@map("chat_participants")
}

model ChatMessage {
  id             String                @id @default(cuid())
  conversationId String
  authorId       String
  content        String
  type           String                @default("text") // 'text', 'image', 'link', 'mixed', 'system'
  metadata       Json?                 // Link previews, image info, etc.
  createdAt      DateTime              @default(now())
  updatedAt      DateTime              @updatedAt
  deletedAt      DateTime?             // Soft delete
  isHidden       Boolean               @default(false) // Moderation: hidden by admin
  hiddenBy       String?               // User ID who hid the message
  hiddenAt       DateTime?             // When message was hidden
  
  // Relations
  conversation   ChatConversation      @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  author         User                  @relation(fields: [authorId], references: [id], onDelete: Cascade)
  reactions      ChatMessageReaction[]
  hiddenByUser   User?                 @relation("HiddenMessages", fields: [hiddenBy], references: [id], onDelete: SetNull)
  
  @@map("chat_messages")
}

model ChatMessageReaction {
  id        String      @id @default(cuid())
  messageId String
  userId    String
  emoji     String      // Unicode emoji character (👍, ❤️, 😂, etc.)
  createdAt DateTime    @default(now())
  
  // Relations
  message   ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([messageId, userId, emoji]) // Prevent duplicate reactions
  @@map("chat_message_reactions")
}

model AIRequest {
  id               String   @id @default(cuid())
  userId           String
  requestType      String   // 'relation_star_individual' | 'relation_star_comparison' | 'group_health' | 'custom'
  requestedAt      DateTime @default(now())
  
  // Flexible input - stored as JSON
  requestInput     String   @db.Text  // JSON string containing all context and data for AI
  requestContext   String?  @db.Text  // JSON string containing metadata (e.g., aboutUserId, aboutGroupId)
  
  // AI response
  provider         String   // 'openai' | 'anthropic' | 'google'
  model            String
  systemPrompt     String   @db.Text
  userPrompt       String   @db.Text
  response         String   @db.Text
  tokensUsed       Int?
  costUsd          Float?
  
  // Conversation support (for future use)
  conversationId   String?  // Groups related requests together
  parentRequestId  String?  // References previous request in conversation
  isFollowUp       Boolean  @default(false)
  
  // Cost control
  creditsUsed      Int?     // For future credit system
  
  // Metadata
  processingTimeMs Int?
  error            String?  @db.Text
  
  // Relations
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  parentRequest    AIRequest? @relation("AIRequestThread", fields: [parentRequestId], references: [id])
  followUpRequests AIRequest[] @relation("AIRequestThread")
  
  @@index([userId, requestedAt])
  @@index([requestType])
  @@index([conversationId])
  @@map("ai_requests")
}
